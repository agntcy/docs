# SLIM Messaging Glossary

This glossary defines technical terms referenced across the SLIM messaging documentation: core concepts, naming, sessions, routing, configuration, security, integrations (SLIMRPC, A2A, MCP), and deployment tooling. Terms are alphabetized.

---

## A

### Ack (Acknowledgment)
A confirmation—explicit or implicit—that a sent message was delivered or processed. In reliable modes, missing acks trigger retries until `max_retries` is reached or a timeout fires.

### Anycast
Session/routing mode where a message addressed to a 3‑component name (`org/namespace/service`) is delivered to exactly one currently reachable instance. Each message may choose a different instance. Useful for stateless load distribution and discovery.

---

## C

### Channel (Multicast Channel / Group)
Logical multicast namespace: the first three SLIM name components (`org/namespace/service`) without the client hash. All joined participants receive each multicast message. Also referred to as a Group.

### Channel Moderator
Privileged manager of a multicast channel that can invites/removes participants and coordinates MLS state.

### Client (Application Client)
Runtime endpoint connected to a SLIM node. Identified by full four-component name: `org/namespace/service/clientHash`.



### Client Instance ID (Client Hash)
Fourth name component, derived from identity material (e.g., hash of public key). Ensures unique, routable unicast identity per instance.

### Connection (Routing Connection)
Configured link (endpoint + parameters) enabling a SLIM node to route traffic to another SLIM node.

### Controller (SLIM Controller)
Central orchestration service offering northbound (administrative) and southbound (node) gRPC interfaces for configuration, topology, and group/channel operations.

---

## D

### Data Plane (Messaging Layer)
Operational pipeline for message routing, delivery, encryption (MLS), and session state, implemented in SLIM nodes. It can be used synonymously with "SLIM Node".

### Discovery (Service Discovery via Anycast)
Initial interaction where Anycast picks any available instance; if persistent affinity is needed, Unicast binds subsequent messages to a chosen instance.

---

## E

### Endpoint
Host:port (and scheme) on which a server listens or a client connects (e.g., `http://localhost:46357`).

---

## G

### Group (Multicast Group / Channel)
Set of participants joined to a multicast channel. Shares message distribution and optionally an MLS security context. See also: Channel, Multicast.

---

## I

### Identity
Cryptographic or token-based representation of a workload (shared secret, JWT, SPIFFE SVID) determining trust and naming uniqueness.

### Invitation (Group Invitation)
Control message enabling a client to join an existing multicast group.

---

## L

### Local Name
The fully qualified SLIM name representing the current application endpoint. See Client (Application Client)

---

## M

### Max Retries (Session Config)
Upper limit on retransmission attempts for a single message lacking timely acknowledgment.

### MLS (Message Layer Security)
End-to-end group key agreement and encryption protocol (RFC 9420) providing confidentiality and integrity beyond hop-level TLS termination.

### Moderator
Alias of Channel Moderator.

### Multicast
Session type enabling many-to-many distribution; every message is delivered to all participants in the channel.

---

## N

### Name (SLIM Name)
Structured routing identifier: `organization/namespace/service/clientHash` (full) or the first three components for anycast/channel addressing. The first component, `organization`, usually represents the top‑level administrative or tenant boundary; the second component, `namespace`, can be used to encode environment, region, or an organizational partition; the third component, `service`, specifies the service exposed by the client. When multiple instances of the same service are deployed (such as several pods in a Kubernetes cluster), these first three components remain the same for all instances. The last component, `clientHash`, is generated by SLIM from the client's identity material (e.g., a hash of the public key) and uniquely identifies each specific client instance.

### Node (SLIM Node)
Runtime process implementing the data plane: message routing, session handling, MLS operations, optional control endpoints.

---

## P

### Participant (Group Participant)
Client that has accepted an invitation and joined a multicast group, receiving all channel traffic.

---

## R

### Retry
Re-attempt of sending a message after a timeout window, capped by `max_retries`.

### Route (Routing Entry)
Controller-managed mapping directing messages for a particular name (or prefix) through a specific connection.

---

## S

### Session
Abstraction for interaction context (Anycast, Unicast, Multicast). Manages encryption (if MLS enabled), retries, and sequencing.

### Session Configuration
Per-session parameters selected at creation (e.g., mode, `mls_enabled`, metadata). In Python bindings: `PySessionConfiguration.Unicast(...)`, etc.

### Session Layer
Middleware that abstracts encryption, invitations, routing resolution, and reliability, offering simple send/receive primitives.

### Shared Secret Identity
Simplest identity bootstrap (common secret) for demos/tests before stronger mechanisms (e.g., JWT) are deployed.

### Slimctl
Command-line tool managing routes, connections, subscriptions, and nodes via Controller or direct node endpoints.

### SLIM (Secure Low-Latency Interactive Messaging)
Framework delivering secure, scalable, low-latency messaging with unified naming, session semantics, encryption, and extensibility.

### SLIMA2A
Integration of A2A agent protocol over SLIM using SLIMRPC-generated stubs.

### SLIM Controller
See Controller.

### SLIMRPC
Protobuf-based RPC framework operating over SLIM transport (unary and streaming patterns). Analogous to gRPC but using SLIM naming and channels.

### SLIMRPC Compiler (protoc-slimrpc-plugin)
Protoc plugin generating Python stubs and servicers for SLIMRPC services defined in `.proto` files.

### Subscription
Binding between a routed name/prefix and a connection so messages destined to that name traverse the appropriate path.

### Publish
Operation that sends a message on a session (context: unicast/anycast/multicast). May await acknowledgment depending on reliability mode. In Python bindings: `session.publish(...)` or `session.publish_to(ctx, ...)`.

### Message Context
Metadata accompanying a received message (e.g., routing info). Used to reply (`publish_to`) preserving addressing.

---

## T

### Timeout (Request / Session Timeout)
Upper bound for waiting on acknowledgments or RPC responses before retry/failure escalation.

---

## U

### Unicast
Session mode binding communication to a specific discovered instance after an initial discovery. Ensures message affinity to a single endpoint.
